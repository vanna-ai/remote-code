// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: competitions.sql

package db

import (
	"context"
	"database/sql"
)

const createCompetition = `-- name: CreateCompetition :one
INSERT INTO agent_competitions (
    task_id, agent1_id, agent2_id, 
    agent1_execution_id, agent2_execution_id,
    winner_agent_id, agent1_elo_before, agent2_elo_before,
    agent1_elo_after, agent2_elo_after, k_factor,
    competition_type, notes
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, task_id, agent1_id, agent2_id, agent1_execution_id, agent2_execution_id, winner_agent_id, agent1_elo_before, agent2_elo_before, agent1_elo_after, agent2_elo_after, k_factor, competition_type, notes, created_at, updated_at
`

type CreateCompetitionParams struct {
	TaskID            int64           `db:"task_id" json:"task_id"`
	Agent1ID          int64           `db:"agent1_id" json:"agent1_id"`
	Agent2ID          int64           `db:"agent2_id" json:"agent2_id"`
	Agent1ExecutionID int64           `db:"agent1_execution_id" json:"agent1_execution_id"`
	Agent2ExecutionID int64           `db:"agent2_execution_id" json:"agent2_execution_id"`
	WinnerAgentID     sql.NullInt64   `db:"winner_agent_id" json:"winner_agent_id"`
	Agent1EloBefore   float64         `db:"agent1_elo_before" json:"agent1_elo_before"`
	Agent2EloBefore   float64         `db:"agent2_elo_before" json:"agent2_elo_before"`
	Agent1EloAfter    float64         `db:"agent1_elo_after" json:"agent1_elo_after"`
	Agent2EloAfter    float64         `db:"agent2_elo_after" json:"agent2_elo_after"`
	KFactor           sql.NullFloat64 `db:"k_factor" json:"k_factor"`
	CompetitionType   sql.NullString  `db:"competition_type" json:"competition_type"`
	Notes             sql.NullString  `db:"notes" json:"notes"`
}

func (q *Queries) CreateCompetition(ctx context.Context, arg CreateCompetitionParams) (AgentCompetition, error) {
	row := q.db.QueryRowContext(ctx, createCompetition,
		arg.TaskID,
		arg.Agent1ID,
		arg.Agent2ID,
		arg.Agent1ExecutionID,
		arg.Agent2ExecutionID,
		arg.WinnerAgentID,
		arg.Agent1EloBefore,
		arg.Agent2EloBefore,
		arg.Agent1EloAfter,
		arg.Agent2EloAfter,
		arg.KFactor,
		arg.CompetitionType,
		arg.Notes,
	)
	var i AgentCompetition
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Agent1ID,
		&i.Agent2ID,
		&i.Agent1ExecutionID,
		&i.Agent2ExecutionID,
		&i.WinnerAgentID,
		&i.Agent1EloBefore,
		&i.Agent2EloBefore,
		&i.Agent1EloAfter,
		&i.Agent2EloAfter,
		&i.KFactor,
		&i.CompetitionType,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompetition = `-- name: GetCompetition :one
SELECT id, task_id, agent1_id, agent2_id, agent1_execution_id, agent2_execution_id, winner_agent_id, agent1_elo_before, agent2_elo_before, agent1_elo_after, agent2_elo_after, k_factor, competition_type, notes, created_at, updated_at FROM agent_competitions
WHERE id = ?
`

func (q *Queries) GetCompetition(ctx context.Context, id int64) (AgentCompetition, error) {
	row := q.db.QueryRowContext(ctx, getCompetition, id)
	var i AgentCompetition
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Agent1ID,
		&i.Agent2ID,
		&i.Agent1ExecutionID,
		&i.Agent2ExecutionID,
		&i.WinnerAgentID,
		&i.Agent1EloBefore,
		&i.Agent2EloBefore,
		&i.Agent1EloAfter,
		&i.Agent2EloAfter,
		&i.KFactor,
		&i.CompetitionType,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompetitionHistory = `-- name: GetCompetitionHistory :many
SELECT id, task_id, agent1_id, agent1_name, agent2_id, agent2_name, winner_agent_id, winner_name, agent1_elo_before, agent2_elo_before, agent1_elo_after, agent2_elo_after, agent1_elo_change, agent2_elo_change, k_factor, competition_type, notes, created_at FROM competition_history
ORDER BY created_at DESC
`

func (q *Queries) GetCompetitionHistory(ctx context.Context) ([]CompetitionHistory, error) {
	rows, err := q.db.QueryContext(ctx, getCompetitionHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompetitionHistory
	for rows.Next() {
		var i CompetitionHistory
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Agent1ID,
			&i.Agent1Name,
			&i.Agent2ID,
			&i.Agent2Name,
			&i.WinnerAgentID,
			&i.WinnerName,
			&i.Agent1EloBefore,
			&i.Agent2EloBefore,
			&i.Agent1EloAfter,
			&i.Agent2EloAfter,
			&i.Agent1EloChange,
			&i.Agent2EloChange,
			&i.KFactor,
			&i.CompetitionType,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompetitionHistoryByAgent = `-- name: GetCompetitionHistoryByAgent :many
SELECT id, task_id, agent1_id, agent1_name, agent2_id, agent2_name, winner_agent_id, winner_name, agent1_elo_before, agent2_elo_before, agent1_elo_after, agent2_elo_after, agent1_elo_change, agent2_elo_change, k_factor, competition_type, notes, created_at FROM competition_history
WHERE agent1_id = ? OR agent2_id = ?
ORDER BY created_at DESC
`

type GetCompetitionHistoryByAgentParams struct {
	Agent1ID int64 `db:"agent1_id" json:"agent1_id"`
	Agent2ID int64 `db:"agent2_id" json:"agent2_id"`
}

func (q *Queries) GetCompetitionHistoryByAgent(ctx context.Context, arg GetCompetitionHistoryByAgentParams) ([]CompetitionHistory, error) {
	rows, err := q.db.QueryContext(ctx, getCompetitionHistoryByAgent, arg.Agent1ID, arg.Agent2ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompetitionHistory
	for rows.Next() {
		var i CompetitionHistory
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Agent1ID,
			&i.Agent1Name,
			&i.Agent2ID,
			&i.Agent2Name,
			&i.WinnerAgentID,
			&i.WinnerName,
			&i.Agent1EloBefore,
			&i.Agent2EloBefore,
			&i.Agent1EloAfter,
			&i.Agent2EloAfter,
			&i.Agent1EloChange,
			&i.Agent2EloChange,
			&i.KFactor,
			&i.CompetitionType,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExistingCompetition = `-- name: GetExistingCompetition :one
SELECT id, task_id, agent1_id, agent2_id, agent1_execution_id, agent2_execution_id, winner_agent_id, agent1_elo_before, agent2_elo_before, agent1_elo_after, agent2_elo_after, k_factor, competition_type, notes, created_at, updated_at FROM agent_competitions
WHERE task_id = ? AND 
      ((agent1_id = ? AND agent2_id = ? AND agent1_execution_id = ? AND agent2_execution_id = ?) OR
       (agent1_id = ? AND agent2_id = ? AND agent1_execution_id = ? AND agent2_execution_id = ?))
LIMIT 1
`

type GetExistingCompetitionParams struct {
	TaskID              int64 `db:"task_id" json:"task_id"`
	Agent1ID            int64 `db:"agent1_id" json:"agent1_id"`
	Agent2ID            int64 `db:"agent2_id" json:"agent2_id"`
	Agent1ExecutionID   int64 `db:"agent1_execution_id" json:"agent1_execution_id"`
	Agent2ExecutionID   int64 `db:"agent2_execution_id" json:"agent2_execution_id"`
	Agent1ID_2          int64 `db:"agent1_id_2" json:"agent1_id_2"`
	Agent2ID_2          int64 `db:"agent2_id_2" json:"agent2_id_2"`
	Agent1ExecutionID_2 int64 `db:"agent1_execution_id_2" json:"agent1_execution_id_2"`
	Agent2ExecutionID_2 int64 `db:"agent2_execution_id_2" json:"agent2_execution_id_2"`
}

func (q *Queries) GetExistingCompetition(ctx context.Context, arg GetExistingCompetitionParams) (AgentCompetition, error) {
	row := q.db.QueryRowContext(ctx, getExistingCompetition,
		arg.TaskID,
		arg.Agent1ID,
		arg.Agent2ID,
		arg.Agent1ExecutionID,
		arg.Agent2ExecutionID,
		arg.Agent1ID_2,
		arg.Agent2ID_2,
		arg.Agent1ExecutionID_2,
		arg.Agent2ExecutionID_2,
	)
	var i AgentCompetition
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Agent1ID,
		&i.Agent2ID,
		&i.Agent1ExecutionID,
		&i.Agent2ExecutionID,
		&i.WinnerAgentID,
		&i.Agent1EloBefore,
		&i.Agent2EloBefore,
		&i.Agent1EloAfter,
		&i.Agent2EloAfter,
		&i.KFactor,
		&i.CompetitionType,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHeadToHeadRecord = `-- name: GetHeadToHeadRecord :one
SELECT 
    COUNT(*) as total_games,
    SUM(CASE WHEN winner_agent_id = ? THEN 1 ELSE 0 END) as agent1_wins,
    SUM(CASE WHEN winner_agent_id = ? THEN 1 ELSE 0 END) as agent2_wins,
    SUM(CASE WHEN winner_agent_id IS NULL THEN 1 ELSE 0 END) as draws
FROM agent_competitions
WHERE (agent1_id = ? AND agent2_id = ?) OR (agent1_id = ? AND agent2_id = ?)
`

type GetHeadToHeadRecordParams struct {
	WinnerAgentID   sql.NullInt64 `db:"winner_agent_id" json:"winner_agent_id"`
	WinnerAgentID_2 sql.NullInt64 `db:"winner_agent_id_2" json:"winner_agent_id_2"`
	Agent1ID        int64         `db:"agent1_id" json:"agent1_id"`
	Agent2ID        int64         `db:"agent2_id" json:"agent2_id"`
	Agent1ID_2      int64         `db:"agent1_id_2" json:"agent1_id_2"`
	Agent2ID_2      int64         `db:"agent2_id_2" json:"agent2_id_2"`
}

type GetHeadToHeadRecordRow struct {
	TotalGames int64           `db:"total_games" json:"total_games"`
	Agent1Wins sql.NullFloat64 `db:"agent1_wins" json:"agent1_wins"`
	Agent2Wins sql.NullFloat64 `db:"agent2_wins" json:"agent2_wins"`
	Draws      sql.NullFloat64 `db:"draws" json:"draws"`
}

func (q *Queries) GetHeadToHeadRecord(ctx context.Context, arg GetHeadToHeadRecordParams) (GetHeadToHeadRecordRow, error) {
	row := q.db.QueryRowContext(ctx, getHeadToHeadRecord,
		arg.WinnerAgentID,
		arg.WinnerAgentID_2,
		arg.Agent1ID,
		arg.Agent2ID,
		arg.Agent1ID_2,
		arg.Agent2ID_2,
	)
	var i GetHeadToHeadRecordRow
	err := row.Scan(
		&i.TotalGames,
		&i.Agent1Wins,
		&i.Agent2Wins,
		&i.Draws,
	)
	return i, err
}

const listCompetitions = `-- name: ListCompetitions :many
SELECT id, task_id, agent1_id, agent2_id, agent1_execution_id, agent2_execution_id, winner_agent_id, agent1_elo_before, agent2_elo_before, agent1_elo_after, agent2_elo_after, k_factor, competition_type, notes, created_at, updated_at FROM agent_competitions
ORDER BY created_at DESC
`

func (q *Queries) ListCompetitions(ctx context.Context) ([]AgentCompetition, error) {
	rows, err := q.db.QueryContext(ctx, listCompetitions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgentCompetition
	for rows.Next() {
		var i AgentCompetition
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Agent1ID,
			&i.Agent2ID,
			&i.Agent1ExecutionID,
			&i.Agent2ExecutionID,
			&i.WinnerAgentID,
			&i.Agent1EloBefore,
			&i.Agent2EloBefore,
			&i.Agent1EloAfter,
			&i.Agent2EloAfter,
			&i.KFactor,
			&i.CompetitionType,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompetitionsByAgent = `-- name: ListCompetitionsByAgent :many
SELECT id, task_id, agent1_id, agent2_id, agent1_execution_id, agent2_execution_id, winner_agent_id, agent1_elo_before, agent2_elo_before, agent1_elo_after, agent2_elo_after, k_factor, competition_type, notes, created_at, updated_at FROM agent_competitions
WHERE agent1_id = ? OR agent2_id = ?
ORDER BY created_at DESC
`

type ListCompetitionsByAgentParams struct {
	Agent1ID int64 `db:"agent1_id" json:"agent1_id"`
	Agent2ID int64 `db:"agent2_id" json:"agent2_id"`
}

func (q *Queries) ListCompetitionsByAgent(ctx context.Context, arg ListCompetitionsByAgentParams) ([]AgentCompetition, error) {
	rows, err := q.db.QueryContext(ctx, listCompetitionsByAgent, arg.Agent1ID, arg.Agent2ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgentCompetition
	for rows.Next() {
		var i AgentCompetition
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Agent1ID,
			&i.Agent2ID,
			&i.Agent1ExecutionID,
			&i.Agent2ExecutionID,
			&i.WinnerAgentID,
			&i.Agent1EloBefore,
			&i.Agent2EloBefore,
			&i.Agent1EloAfter,
			&i.Agent2EloAfter,
			&i.KFactor,
			&i.CompetitionType,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompetitionsByTask = `-- name: ListCompetitionsByTask :many
SELECT id, task_id, agent1_id, agent2_id, agent1_execution_id, agent2_execution_id, winner_agent_id, agent1_elo_before, agent2_elo_before, agent1_elo_after, agent2_elo_after, k_factor, competition_type, notes, created_at, updated_at FROM agent_competitions
WHERE task_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListCompetitionsByTask(ctx context.Context, taskID int64) ([]AgentCompetition, error) {
	rows, err := q.db.QueryContext(ctx, listCompetitionsByTask, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgentCompetition
	for rows.Next() {
		var i AgentCompetition
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Agent1ID,
			&i.Agent2ID,
			&i.Agent1ExecutionID,
			&i.Agent2ExecutionID,
			&i.WinnerAgentID,
			&i.Agent1EloBefore,
			&i.Agent2EloBefore,
			&i.Agent1EloAfter,
			&i.Agent2EloAfter,
			&i.KFactor,
			&i.CompetitionType,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
